# This file was auto generated by Styx.
# Do not edit this file directly.

from styxdefs import *
import pathlib
import typing

_SSWARPER_METADATA = Metadata(
    id="9d42376738784f0965491de65ea136af17108125",
    name="@SSwarper",
    container_image_type="docker",
    container_image_index="index.docker.io",
    container_image_tag="afni/afni_latest",
)


class SswarperOutputs(typing.NamedTuple):
    """
    Output object returned when calling `_sswarper(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    anat_do: OutputPathType
    """Deobliqued version of original dataset"""
    anat_u: OutputPathType
    """Intensity uniform-ized original dataset"""
    anat_ua: OutputPathType
    """Anisotropically smoothed version of the uniformized dataset"""
    anat_uac: OutputPathType
    """Ceiling-capped version of the anisotropically smoothed dataset"""
    anat_s: OutputPathType
    """First pass skull-stripped original dataset"""
    anat_ss: OutputPathType
    """Second pass skull-stripped original dataset"""
    anat_qq: OutputPathType
    """Skull-stripped dataset nonlinearly warped to the base template space"""
    anat_qq_affine: OutputPathType
    """Affine matrix to transform original dataset to base template space"""
    anat_qq_warp: OutputPathType
    """Incremental warp from affine transformation to nonlinearly aligned dataset"""
    am_snapshot: OutputPathType
    """3x3 snapshot image of the nonlinearly warped dataset with edges from the base template overlaid"""
    ma_snapshot: OutputPathType
    """Similar to AM_snapshot, but with roles of the template and anatomical dataset reversed"""
    qc_anat_qq: OutputPathType
    """3 rows of 8 slices snapshot image for checking alignment"""
    qc_anat_ss: OutputPathType
    """Snapshot image to check skullstripping in original space"""
    init_overlap_qc: OutputPathType
    """Montage to check initial overlap of source and base datasets"""


def _sswarper(
    input_file: InputPathType,
    base_template: InputPathType,
    subject_id: str,
    output_dir: str | None = None,
    min_patch_size: float | int | None = None,
    no_lite: bool = False,
    skip_warp: bool = False,
    unifize_off: bool = False,
    init_skullstr_off: bool = False,
    extra_qc_off: bool = False,
    jump_to_extra_qc: bool = False,
    cost_nl_init: str | None = None,
    cost_nl_final: str | None = None,
    deoblique: bool = False,
    deoblique_refitly: bool = False,
    warp_scale: float | int | None = None,
    ssopt_flag: str | None = None,
    aniso_off: bool = False,
    ceil_off: bool = False,
    tmp_name_nice: bool = False,
    echo: bool = False,
    verbose: bool = False,
    noclean: bool = False,
    runner: Runner | None = None,
) -> SswarperOutputs:
    """
    @SSwarper by Bob, Bob, there is one Bob, He spells it B-O-B..
    
    Dual purposes for processing a given subject's anatomical volume:
    skull-strip the brain and calculate the warp to a reference
    template/standard space.
    
    More information: https://afni.nimh.nih.gov/
    
    Args:
        input_file: An anatomical dataset, not skull-stripped, with about 1 mm\
            resolution.
        base_template: A base template dataset with similar contrast to the\
            input dataset.
        subject_id: Name code for output datasets (e.g., 'sub007').
        output_dir: Output directory for all files from this program.
        min_patch_size: Minimum patch size on final 3dQwarp.
        no_lite: Do not use the '-lite' option with 3dQwarp.
        skip_warp: Do not compute past the output of anatSS.<subid>.nii.
        unifize_off: Do not start with a 3dUnifize command.
        init_skullstr_off: Do not preprocess with a 3dSkullstrip command.
        extra_qc_off: Do not make extra QC images.
        jump_to_extra_qc: Just make the two QC*jpg images from a previous run.
        cost_nl_init: Specify cost function for initial nonlinear (3dQwarp)\
            part of alignment.
        cost_nl_final: Specify cost function for final nonlinear (3dQwarp)\
            parts of alignment.
        deoblique: Apply obliquity information to deoblique the input volume.
        deoblique_refitly: Purge obliquity information to deoblique the input\
            volume.
        warp_scale: Control flexibility of warps in 3dQwarp.
        ssopt_flag: Append a string of options for 3dSkullStrip.
        aniso_off: Do not preprocess with a 3danisosmooth command.
        ceil_off: Turn off capping on values after anisosmoothing.
        tmp_name_nice: Use nicer, non-random intermediate file prefix for\
            temporary files.
        echo: Run the script with 'set echo' for extra verbosity in the\
            terminal output.
        verbose: Apply the '-verb' option to 3dQwarp for verbose progress\
            information.
        noclean: Do not delete the 'junk' files at the end of computations.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `SswarperOutputs`).
    """
    runner = runner or get_global_runner()
    if warp_scale is not None and not (0.1 <= warp_scale <= 1.0): 
        raise ValueError(f"'warp_scale' must be between 0.1 <= x <= 1.0 but was {warp_scale}")
    execution = runner.start_execution(_SSWARPER_METADATA)
    cargs = []
    cargs.append("@SSwarper")
    cargs.append("-input")
    cargs.append(execution.input_file(input_file))
    cargs.append("-base")
    cargs.append(execution.input_file(base_template))
    cargs.append("-subid")
    cargs.append(subject_id)
    if output_dir is not None:
        cargs.extend(["-odir", output_dir])
    if min_patch_size is not None:
        cargs.extend(["-minp", str(min_patch_size)])
    if no_lite:
        cargs.append("-nolite")
    if skip_warp:
        cargs.append("-skipwarp")
    if unifize_off:
        cargs.append("-unifize_off")
    if init_skullstr_off:
        cargs.append("-init_skullstr_off")
    if extra_qc_off:
        cargs.append("-extra_qc_off")
    if jump_to_extra_qc:
        cargs.append("-jump_to_extra_qc")
    if cost_nl_init is not None:
        cargs.extend(["-cost_nl_init", cost_nl_init])
    if cost_nl_final is not None:
        cargs.extend(["-cost_nl_final", cost_nl_final])
    if deoblique:
        cargs.append("-deoblique")
    if deoblique_refitly:
        cargs.append("-deoblique_refitly")
    if warp_scale is not None:
        cargs.extend(["-warpscale", str(warp_scale)])
    if ssopt_flag is not None:
        cargs.extend(["-SSopt", ssopt_flag])
    if aniso_off:
        cargs.append("-aniso_off")
    if ceil_off:
        cargs.append("-ceil_off")
    if tmp_name_nice:
        cargs.append("-tmp_name_nice")
    if echo:
        cargs.append("-echo")
    if verbose:
        cargs.append("-verb")
    if noclean:
        cargs.append("-noclean")
    ret = SswarperOutputs(
        root=execution.output_file("."),
        anat_do=execution.output_file(f"anatDO.{subject_id}.nii", optional=True),
        anat_u=execution.output_file(f"anatU.{subject_id}.nii", optional=True),
        anat_ua=execution.output_file(f"anatUA.{subject_id}.nii", optional=True),
        anat_uac=execution.output_file(f"anatUAC.{subject_id}.nii", optional=True),
        anat_s=execution.output_file(f"anatS.{subject_id}.nii", optional=True),
        anat_ss=execution.output_file(f"anatSS.{subject_id}.nii", optional=True),
        anat_qq=execution.output_file(f"anatQQ.{subject_id}.nii", optional=True),
        anat_qq_affine=execution.output_file(f"anatQQ.{subject_id}.aff12.1D", optional=True),
        anat_qq_warp=execution.output_file(f"anatQQ.{subject_id}_WARP.nii", optional=True),
        am_snapshot=execution.output_file(f"AM{subject_id}.jpg", optional=True),
        ma_snapshot=execution.output_file(f"MA{subject_id}.jpg", optional=True),
        qc_anat_qq=execution.output_file(f"QC_anatQQ.{subject_id}.jpg", optional=True),
        qc_anat_ss=execution.output_file(f"QC_anatSS.{subject_id}.jpg", optional=True),
        init_overlap_qc=execution.output_file(f"init_qc_00_overlap_uinp_obase.jpg", optional=True),
    )
    execution.run(cargs)
    return ret


__all__ = [
    "SswarperOutputs",
    "_SSWARPER_METADATA",
    "_sswarper",
]
