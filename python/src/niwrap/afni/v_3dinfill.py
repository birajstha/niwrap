# This file was auto generated by Styx.
# Do not edit this file directly.

from styxdefs import *
import pathlib
import typing

V_3DINFILL_METADATA = Metadata(
    id="61327133cb76705dfae6ce1c65d13de99638bccb",
    name="3dinfill",
    container_image_type="docker",
    container_image_index="index.docker.io",
    container_image_tag="example/3dinfill:latest",
)


class V3dinfillOutputs(typing.NamedTuple):
    """
    Output object returned when calling `v_3dinfill(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_filled: OutputPathType | None
    """Filled volume output"""


def v_3dinfill(
    input_: InputPathType,
    prefix: str | None = None,
    niter: float | int | None = None,
    blend: typing.Literal["MODE", "AVG", "AUTO", "SOLID", "SOLID_CLEAN"] | None = None,
    minhits: float | int | None = None,
    ed: list[float | int] | None = None,
    mask: InputPathType | None = None,
    mask_range: list[float | int] | None = None,
    mrange: list[float | int] | None = None,
    cmask: str | None = None,
    runner: Runner | None = None,
) -> V3dinfillOutputs:
    """
    3dinfill by Author Name.
    
    A program to fill holes in volumes.
    
    More information: https://example.com/3dinfill
    
    Args:
        input_: Fill volume dataset.
        prefix: Use PREF for output prefix.
        niter: Do not allow the fill function to do more than NITER passes.
        blend: Method for assigning a value to a hole.
        minhits: Criterion for considering a zero voxel to be a hole. Can only\
            be used with -blend SOLID.
        ed: Erode N times then dilate N times to get rid of hanging chunks.\
            Values filled in by this process get value V.
        mask: Provide mask dataset to select subset of input.
        mask_range: Specify the range of values to consider from mask dataset.
        mrange: Alias for -mask_range option.
        cmask: Provide cmask expression. Voxels where expression is 0 are\
            excluded from computations.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `V3dinfillOutputs`).
    """
    runner = runner or get_global_runner()
    if ed is not None and (len(ed) != 2): 
        raise ValueError(f"Length of 'ed' must be 2 but was {len(ed)}")
    if mask_range is not None and (len(mask_range) != 2): 
        raise ValueError(f"Length of 'mask_range' must be 2 but was {len(mask_range)}")
    if mrange is not None and (len(mrange) != 2): 
        raise ValueError(f"Length of 'mrange' must be 2 but was {len(mrange)}")
    execution = runner.start_execution(V_3DINFILL_METADATA)
    cargs = []
    cargs.append("3dinfill")
    cargs.extend(["-input", execution.input_file(input_)])
    if prefix is not None:
        cargs.extend(["-prefix", prefix])
    if niter is not None:
        cargs.extend(["-Niter", str(niter)])
    if blend is not None:
        cargs.extend(["-blend", blend])
    if minhits is not None:
        cargs.extend(["-minhits", str(minhits)])
    if ed is not None:
        cargs.extend(["-ed", *map(str, ed)])
    if mask is not None:
        cargs.extend(["-mask", execution.input_file(mask)])
    if mask_range is not None:
        cargs.extend(["-mask_range", *map(str, mask_range)])
    if mrange is not None:
        cargs.extend(["-mrange", *map(str, mrange)])
    if cmask is not None:
        cargs.extend(["-cmask", cmask])
    ret = V3dinfillOutputs(
        root=execution.output_file("."),
        output_filled=execution.output_file(f"{prefix}_filled.nii.gz", optional=True) if prefix is not None else None,
    )
    execution.run(cargs)
    return ret


__all__ = [
    "V3dinfillOutputs",
    "V_3DINFILL_METADATA",
    "v_3dinfill",
]
