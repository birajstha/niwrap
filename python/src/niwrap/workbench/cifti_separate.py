# This file was auto generated by Styx.
# Do not edit this file directly.

import dataclasses
import pathlib
import typing

from styxdefs import *


CIFTI_SEPARATE_METADATA = Metadata(
    id="e9badfe1e47d0bc56af787769753d71bb546d660",
    name="cifti-separate",
    container_image_type="docker",
    container_image_tag="fcpindi/c-pac:latest",
)


class CiftiSeparateVolumeAllOutputs(typing.NamedTuple):
    """
    Output object returned when calling `CiftiSeparateVolumeAll.run(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    volume_out: OutputPathType
    """the output volume"""
    roi_out: OutputPathType
    """the roi output volume"""
    label_out: OutputPathType
    """the label output volume"""


@dataclasses.dataclass
class CiftiSeparateVolumeAll:
    """
    separate all volume structures into a volume file
    """
    volume_out: InputPathType
    """the output volume"""
    opt_roi: bool = False
    """also output the roi of which voxels have data"""
    roi_out: InputPathType
    """the roi output volume"""
    opt_label: bool = False
    """output a volume label file indicating the location of structures"""
    label_out: InputPathType
    """the label output volume"""
    opt_crop: bool = False
    """crop volume to the size of the data rather than using the original volume
    size"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append(execution.input_file(self.volume_out))
        if self.opt_roi:
            cargs.append("-roi")
        cargs.append(execution.input_file(self.roi_out))
        if self.opt_label:
            cargs.append("-label")
        cargs.append(execution.input_file(self.label_out))
        if self.opt_crop:
            cargs.append("-crop")
        return cargs
    
    def outputs(
        self,
        execution: Execution,
    ) -> CiftiSeparateVolumeAllOutputs:
        """
        Collect output file paths.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            NamedTuple of outputs (described in `CiftiSeparateVolumeAllOutputs`).
        """
        ret = CiftiSeparateVolumeAllOutputs(
            root=execution.output_file("."),
            volume_out=execution.output_file(f"{pathlib.Path(self.volume_out).name}"),
            roi_out=execution.output_file(f"{pathlib.Path(self.roi_out).name}"),
            label_out=execution.output_file(f"{pathlib.Path(self.label_out).name}"),
        )
        return ret


class CiftiSeparateLabelOutputs(typing.NamedTuple):
    """
    Output object returned when calling `CiftiSeparateLabel.run(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    label_out_: OutputPathType
    """the output label file"""
    roi_out_: OutputPathType
    """the roi output metric"""


@dataclasses.dataclass
class CiftiSeparateLabel:
    """
    separate a surface model into a surface label file
    """
    label_out: InputPathType
    """the output label file"""
    opt_roi: bool = False
    """also output the roi of which vertices have data"""
    roi_out: InputPathType
    """the roi output metric"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append(execution.input_file(self.label_out))
        if self.opt_roi:
            cargs.append("-roi")
        cargs.append(execution.input_file(self.roi_out))
        return cargs
    
    def outputs(
        self,
        execution: Execution,
    ) -> CiftiSeparateLabelOutputs:
        """
        Collect output file paths.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            NamedTuple of outputs (described in `CiftiSeparateLabelOutputs`).
        """
        ret = CiftiSeparateLabelOutputs(
            root=execution.output_file("."),
            label_out_=execution.output_file(f"{pathlib.Path(self.label_out).name}"),
            roi_out_=execution.output_file(f"{pathlib.Path(self.roi_out).name}"),
        )
        return ret


class CiftiSeparateMetricOutputs(typing.NamedTuple):
    """
    Output object returned when calling `CiftiSeparateMetric.run(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    metric_out: OutputPathType
    """the output metric"""
    roi_out_2: OutputPathType
    """the roi output metric"""


@dataclasses.dataclass
class CiftiSeparateMetric:
    """
    separate a surface model into a metric file
    """
    metric_out: InputPathType
    """the output metric"""
    opt_roi: bool = False
    """also output the roi of which vertices have data"""
    roi_out: InputPathType
    """the roi output metric"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append(execution.input_file(self.metric_out))
        if self.opt_roi:
            cargs.append("-roi")
        cargs.append(execution.input_file(self.roi_out))
        return cargs
    
    def outputs(
        self,
        execution: Execution,
    ) -> CiftiSeparateMetricOutputs:
        """
        Collect output file paths.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            NamedTuple of outputs (described in `CiftiSeparateMetricOutputs`).
        """
        ret = CiftiSeparateMetricOutputs(
            root=execution.output_file("."),
            metric_out=execution.output_file(f"{pathlib.Path(self.metric_out).name}"),
            roi_out_2=execution.output_file(f"{pathlib.Path(self.roi_out).name}"),
        )
        return ret


class CiftiSeparateVolumeOutputs(typing.NamedTuple):
    """
    Output object returned when calling `CiftiSeparateVolume.run(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    volume_out_: OutputPathType
    """the output volume"""
    roi_out_3: OutputPathType
    """the roi output volume"""


@dataclasses.dataclass
class CiftiSeparateVolume:
    """
    separate a volume structure into a volume file
    """
    volume_out: InputPathType
    """the output volume"""
    opt_roi: bool = False
    """also output the roi of which voxels have data"""
    roi_out: InputPathType
    """the roi output volume"""
    opt_crop: bool = False
    """crop volume to the size of the component rather than using the original
    volume size"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append(execution.input_file(self.volume_out))
        if self.opt_roi:
            cargs.append("-roi")
        cargs.append(execution.input_file(self.roi_out))
        if self.opt_crop:
            cargs.append("-crop")
        return cargs
    
    def outputs(
        self,
        execution: Execution,
    ) -> CiftiSeparateVolumeOutputs:
        """
        Collect output file paths.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            NamedTuple of outputs (described in `CiftiSeparateVolumeOutputs`).
        """
        ret = CiftiSeparateVolumeOutputs(
            root=execution.output_file("."),
            volume_out_=execution.output_file(f"{pathlib.Path(self.volume_out).name}"),
            roi_out_3=execution.output_file(f"{pathlib.Path(self.roi_out).name}"),
        )
        return ret


class CiftiSeparateOutputs(typing.NamedTuple):
    """
    Output object returned when calling `cifti_separate(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    volume_all: CiftiSeparateVolumeAllOutputs
    """Subcommand outputs"""
    label: typing.List[CiftiSeparateLabelOutputs]
    """Subcommand outputs"""
    metric: typing.List[CiftiSeparateMetricOutputs]
    """Subcommand outputs"""
    volume: typing.List[CiftiSeparateVolumeOutputs]
    """Subcommand outputs"""


def cifti_separate(
    cifti_in: InputPathType,
    direction: str,
    volume_all: CiftiSeparateVolumeAll | None = None,
    label: list[CiftiSeparateLabel] = None,
    metric: list[CiftiSeparateMetric] = None,
    volume: list[CiftiSeparateVolume] = None,
    runner: Runner = None,
) -> CiftiSeparateOutputs:
    """
    cifti-separate by Washington University School of Medicin.
    
    Write a cifti structure as metric, label or volume.
    
    For dtseries, dscalar, and dlabel, use COLUMN for <direction>, and if you
    have a symmetric dconn, COLUMN is more efficient.
    
    You must specify at least one of -metric, -volume-all, -volume, or -label
    for this command to do anything. Output volumes will spatially line up with
    their original positions, whether or not they are cropped. Volume files
    produced by separating a dlabel file, or from the -label suboption of
    -volume-all, will be label volumes, see -volume-help.
    
    For each <structure> argument, use one of the following strings:
    
    CORTEX_LEFT
    CORTEX_RIGHT
    CEREBELLUM
    ACCUMBENS_LEFT
    ACCUMBENS_RIGHT
    ALL_GREY_MATTER
    ALL_WHITE_MATTER
    AMYGDALA_LEFT
    AMYGDALA_RIGHT
    BRAIN_STEM
    CAUDATE_LEFT
    CAUDATE_RIGHT
    CEREBELLAR_WHITE_MATTER_LEFT
    CEREBELLAR_WHITE_MATTER_RIGHT
    CEREBELLUM_LEFT
    CEREBELLUM_RIGHT
    CEREBRAL_WHITE_MATTER_LEFT
    CEREBRAL_WHITE_MATTER_RIGHT
    CORTEX
    DIENCEPHALON_VENTRAL_LEFT
    DIENCEPHALON_VENTRAL_RIGHT
    HIPPOCAMPUS_LEFT
    HIPPOCAMPUS_RIGHT
    INVALID
    OTHER
    OTHER_GREY_MATTER
    OTHER_WHITE_MATTER
    PALLIDUM_LEFT
    PALLIDUM_RIGHT
    PUTAMEN_LEFT
    PUTAMEN_RIGHT
    THALAMUS_LEFT
    THALAMUS_RIGHT.
    
    Args:
        cifti_in: the cifti to separate a component of
        direction: which direction to separate into components, ROW or COLUMN
        volume_all: separate all volume structures into a volume file
        label: separate a surface model into a surface label file
        metric: separate a surface model into a metric file
        volume: separate a volume structure into a volume file
        runner: Command runner
    Returns:
        NamedTuple of outputs (described in `CiftiSeparateOutputs`).
    """
    runner = runner or get_global_runner()
    execution = runner.start_execution(CIFTI_SEPARATE_METADATA)
    cargs = []
    cargs.append("wb_command")
    cargs.append("-cifti-separate")
    cargs.append(execution.input_file(cifti_in))
    cargs.append(direction)
    if volume_all is not None:
        cargs.extend(["-volume-all", *volume_all.run(execution)])
    if label is not None:
        cargs.extend(["-label", *[a for c in [s.run(execution) for s in label] for a in c]])
    if metric is not None:
        cargs.extend(["-metric", *[a for c in [s.run(execution) for s in metric] for a in c]])
    if volume is not None:
        cargs.extend(["-volume", *[a for c in [s.run(execution) for s in volume] for a in c]])
    ret = CiftiSeparateOutputs(
        root=execution.output_file("."),
        volume_all=volume_all.outputs(execution),
        label=[label.outputs(execution) for label in label],
        metric=[metric.outputs(execution) for metric in metric],
        volume=[volume.outputs(execution) for volume in volume],
    )
    execution.run(cargs)
    return ret


__all__ = [
    "CIFTI_SEPARATE_METADATA",
    "CiftiSeparateLabel",
    "CiftiSeparateLabelOutputs",
    "CiftiSeparateMetric",
    "CiftiSeparateMetricOutputs",
    "CiftiSeparateOutputs",
    "CiftiSeparateVolume",
    "CiftiSeparateVolumeAll",
    "CiftiSeparateVolumeAllOutputs",
    "CiftiSeparateVolumeOutputs",
    "cifti_separate",
]
