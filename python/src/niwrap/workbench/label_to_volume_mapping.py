# This file was auto generated by Styx.
# Do not edit this file directly.

from styxdefs import *
import dataclasses
import pathlib
import typing

LABEL_TO_VOLUME_MAPPING_METADATA = Metadata(
    id="be7301aed515011ae367368ddd9636d55c4a96b8",
    name="label-to-volume-mapping",
    container_image_type="docker",
    container_image_tag="fcpindi/c-pac:latest",
)


@dataclasses.dataclass
class LabelToVolumeMappingRibbonConstrained:
    """
    use ribbon constrained mapping algorithm
    """
    inner_surf: InputPathType
    """the inner surface of the ribbon"""
    outer_surf: InputPathType
    """the outer surface of the ribbon"""
    opt_voxel_subdiv_subdiv_num: int | None = None
    """voxel divisions while estimating voxel weights: number of subdivisions,
    default 3"""
    opt_greedy: bool = False
    """also put labels in voxels with less than 50% partial volume (legacy
    behavior)"""
    opt_thick_columns: bool = False
    """use overlapping columns (legacy method)"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append(execution.input_file(self.inner_surf))
        cargs.append(execution.input_file(self.outer_surf))
        if self.opt_voxel_subdiv_subdiv_num is not None:
            cargs.extend(["-voxel-subdiv", str(self.opt_voxel_subdiv_subdiv_num)])
        if self.opt_greedy:
            cargs.append("-greedy")
        if self.opt_thick_columns:
            cargs.append("-thick-columns")
        return cargs


class LabelToVolumeMappingOutputs(typing.NamedTuple):
    """
    Output object returned when calling `label_to_volume_mapping(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    volume_out: OutputPathType
    """the output volume file"""


def label_to_volume_mapping(
    label: InputPathType,
    surface: InputPathType,
    volume_space: InputPathType,
    volume_out: InputPathType,
    opt_nearest_vertex_distance: float | int | None = None,
    ribbon_constrained: LabelToVolumeMappingRibbonConstrained | None = None,
    runner: Runner = None,
) -> LabelToVolumeMappingOutputs:
    """
    label-to-volume-mapping by Washington University School of Medicin.
    
    Map label file to volume.
    
    Maps labels from a gifti label file into a volume file. You must specify
    exactly one mapping method option. The -nearest-vertex method uses the label
    from the vertex closest to the voxel center. The -ribbon-constrained method
    uses the same method as in -volume-to-surface-mapping, then uses the weights
    in reverse, with popularity logic to decide on a label to use.
    
    Args:
        label: the input label file.
        surface: the surface to use coordinates from.
        volume_space: a volume file in the desired output volume space.
        volume_out: the output volume file.
        opt_nearest_vertex_distance: use the label from the vertex closest to\
            the voxel center: how far from the surface to map labels to voxels, in\
            mm.
        ribbon_constrained: use ribbon constrained mapping algorithm.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `LabelToVolumeMappingOutputs`).
    """
    runner = runner or get_global_runner()
    execution = runner.start_execution(LABEL_TO_VOLUME_MAPPING_METADATA)
    cargs = []
    cargs.append("wb_command")
    cargs.append("-label-to-volume-mapping")
    cargs.append(execution.input_file(label))
    cargs.append(execution.input_file(surface))
    cargs.append(execution.input_file(volume_space))
    cargs.append(execution.input_file(volume_out))
    if opt_nearest_vertex_distance is not None:
        cargs.extend(["-nearest-vertex", str(opt_nearest_vertex_distance)])
    if ribbon_constrained is not None:
        cargs.extend(["-ribbon-constrained", *ribbon_constrained.run(execution)])
    ret = LabelToVolumeMappingOutputs(
        root=execution.output_file("."),
        volume_out=execution.output_file(f"{pathlib.Path(volume_out).name}"),
    )
    execution.run(cargs)
    return ret


__all__ = [
    "LABEL_TO_VOLUME_MAPPING_METADATA",
    "LabelToVolumeMappingOutputs",
    "LabelToVolumeMappingRibbonConstrained",
    "label_to_volume_mapping",
]
