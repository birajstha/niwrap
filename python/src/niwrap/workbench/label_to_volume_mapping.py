# This file was auto generated by Styx.
# Do not edit this file directly.

import dataclasses
import pathlib
import typing

from styxdefs import *


LABEL_TO_VOLUME_MAPPING_METADATA = Metadata(
    id="04fcefafccf6525707a297764c2afa8756687f20",
    name="label-to-volume-mapping",
    container_image_type="docker",
    container_image_tag="fcpindi/c-pac:latest",
)


class LabelToVolumeMappingRibbonConstrainedOutputs(typing.NamedTuple):
    """
    Output object returned when calling `LabelToVolumeMappingRibbonConstrained.run(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""


@dataclasses.dataclass
class LabelToVolumeMappingRibbonConstrained:
    """
    use ribbon constrained mapping algorithm
    """
    opt_voxel_subdiv_subdiv_num: int | None = None
    """voxel divisions while estimating voxel weights: number of subdivisions,
    default 3"""
    opt_greedy: bool = False
    """also put labels in voxels with less than 50% partial volume (legacy
    behavior)"""
    opt_thick_columns: bool = False
    """use overlapping columns (legacy method)"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        if self.opt_voxel_subdiv_subdiv_num is not None:
            cargs.extend(["-voxel-subdiv", str(self.opt_voxel_subdiv_subdiv_num)])
        if self.opt_greedy:
            cargs.append("-greedy")
        if self.opt_thick_columns:
            cargs.append("-thick-columns")
        return cargs
    
    def outputs(
        self,
        execution: Execution,
    ) -> LabelToVolumeMappingRibbonConstrainedOutputs:
        """
        Collect output file paths.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            NamedTuple of outputs (described in `LabelToVolumeMappingRibbonConstrainedOutputs`).
        """
        ret = LabelToVolumeMappingRibbonConstrainedOutputs(
            root=execution.output_file("."),
        )
        return ret


class LabelToVolumeMappingOutputs(typing.NamedTuple):
    """
    Output object returned when calling `label_to_volume_mapping(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    volume_out: OutputPathType
    """the output volume file"""
    ribbon_constrained: LabelToVolumeMappingRibbonConstrainedOutputs
    """Subcommand outputs"""


def label_to_volume_mapping(
    label: InputPathType,
    surface: InputPathType,
    volume_space: InputPathType,
    volume_out: InputPathType,
    opt_nearest_vertex_distance: float | int | None = None,
    ribbon_constrained: LabelToVolumeMappingRibbonConstrained | None = None,
    runner: Runner = None,
) -> LabelToVolumeMappingOutputs:
    """
    label-to-volume-mapping by Washington University School of Medicin.
    
    Map label file to volume.
    
    Maps labels from a gifti label file into a volume file. You must specify
    exactly one mapping method option. The -nearest-vertex method uses the label
    from the vertex closest to the voxel center. The -ribbon-constrained method
    uses the same method as in -volume-to-surface-mapping, then uses the weights
    in reverse, with popularity logic to decide on a label to use.
    
    Args:
        label: the input label file
        surface: the surface to use coordinates from
        volume_space: a volume file in the desired output volume space
        volume_out: the output volume file
        opt_nearest_vertex_distance: use the label from the vertex closest to
            the voxel center: how far from the surface to map labels to voxels, in
            mm
        ribbon_constrained: use ribbon constrained mapping algorithm
        runner: Command runner
    Returns:
        NamedTuple of outputs (described in `LabelToVolumeMappingOutputs`).
    """
    runner = runner or get_global_runner()
    execution = runner.start_execution(LABEL_TO_VOLUME_MAPPING_METADATA)
    cargs = []
    cargs.append("wb_command")
    cargs.append("-label-to-volume-mapping")
    cargs.append(execution.input_file(label))
    cargs.append(execution.input_file(surface))
    cargs.append(execution.input_file(volume_space))
    cargs.append(execution.input_file(volume_out))
    if opt_nearest_vertex_distance is not None:
        cargs.extend(["-nearest-vertex", str(opt_nearest_vertex_distance)])
    if ribbon_constrained is not None:
        cargs.extend(["-ribbon-constrained", *ribbon_constrained.run(execution)])
    ret = LabelToVolumeMappingOutputs(
        root=execution.output_file("."),
        volume_out=execution.output_file(f"{pathlib.Path(volume_out).name}"),
        ribbon_constrained=ribbon_constrained.outputs(execution),
    )
    execution.run(cargs)
    return ret


__all__ = [
    "LABEL_TO_VOLUME_MAPPING_METADATA",
    "LabelToVolumeMappingOutputs",
    "LabelToVolumeMappingRibbonConstrained",
    "LabelToVolumeMappingRibbonConstrainedOutputs",
    "label_to_volume_mapping",
]
